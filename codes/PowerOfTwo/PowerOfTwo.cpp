/**************************************************************************************************
 * 【题目描述】
 * 判断一个整数是否为 2 的幂次方，如果是，则返回true，否则返回false；
 * 
 * 【输入】
 * Input Number = 1024
 * 【输出】
 * true
 * 
 * 【解题思路】
 * 方法一：
 * 最先最直观想到的是对2进行整除，判断给定的整数是否是2的幂次方，首先需要确定该整数对2取余是否为0，排除掉
 * 奇数，其次，如果一个不是2的幂次方的偶数，在对2进行递归整除的时候，迟早整除的结果会变为奇数，基于这两个
 * 条件，当一个大于1的整数（1是2的0次幂）对2取余为0，且递归整除的最后结果是1，则它就是2的幂次方。
 * 
 * 方法二：
 * 通过二进制运算的方式来判断，2的幂次方的二进制数，有如下性质：最高位是1，且二进制数中只有这一个数字1；
 * 基于此性质，如果将一个2的幂次方减去1，则二进制数中，最高位由1变成0，其它所有低位都会变成1，将2的幂次方
 * 与2的幂次方减去1进行按位&运算，因为0和1都刚好错位，所以结果为0，若结果不为0，则不是2的幂次方。核心算子：
 * (2^N) & (2^N - 1) == 0
 * 
 * 方法三：
 * 在计算机中，负数的二进制是采用补码形式来保存的，如果给一个正整数加上一个负号，则计算机中，会将其最高位
 * 设置为1得到原码，其余位取反得到反码，再加上1得到补码。结合2的幂次方的二进制数有且仅有一个数字1在其最高
 * 位，所以对一个2的幂次方乘上-1时，最终存储的补码和2的幂次方进行按位&运算，会得到2的幂次方本身，如果不满
 * 足这个性质，它就不是2的幂次方，举个例子：
 * 0100 0000 原始数据
 * 1100 0000 加上负号变成负整数
 * 1011 1111 取反得到原码
 * 1100 0000 加上1得到补码
 * 可知最终存储的补码 1100 0000 与原始数据，即2的幂次方 0100 0000 进行按位&运算的结果为2的幂次方本身。核
 * 心算子：(2^N) & (-2^N) == N
 * 
 * 方法四：
 * 因为在计算机中，一个给定的数据类型都是有边界的，以当前代码中用 long long int 来举例，不超出该类型的正
 * 整数的2的幂次方最大值，是 2^62，所以，如果给定的该类型的正整数，是2^62的因数，即能够被2^62整除，则给
 * 定的正整数是一个2的幂次方。（也算是一个法子）
 * 
 * 【解题分析】
 * 方法一：
 * 时间复杂度：O(logN) 实际为 log 以 2 为底，N 的对数
 * 空间复杂度：O(1)
 * 方法二：
 * 时间复杂度：O(1)
 * 空间复杂度：O(1)
 * 方法三：
 * 时间复杂度：O(1)
 * 空间复杂度：O(1)
 * 方法四：
 * 时间复杂度：O(1)
 * 空间复杂度：O(1)
 * 
 * @author FrankX
 * @date 2021-09-06
 **************************************************************************************************/
#include <iostream>
using namespace std;

bool PowerOfTwo_1(long long int num)
{
	while (num > 1)
	{
		// 排除奇数，如果偶数不是2的幂次方，在整除2的过程中最终也会变成奇数 
		if (num % 2 != 0) break;
		num = static_cast<long long int>(num / 2);
	}

	return (num == 1);
}

bool PowerOfTwo_2(long long int num)
{
	// 核心算子：(2^N) & (2^N - 1) == 0 
	return (num > 0 && (num & (num - 1)) == 0);
}

bool PowerOfTwo_3(long long int num)
{
	// 核心算子：(2^N) & (-2^N) == N 
	return (num > 0 && (num & -num) == num);
}

bool PowerOfTwo_4(long long int num)
{
	// long long int 类型2的最大次幂是62 : 2^62 = 4'611'686'018'427'387'904 
	static long long int maxPower = (1 << 62);

	return (num > 0 && (maxPower % num) == 0);
}

int main(int argc, char** argv)
{
	long long int num = 1125899906842624; // 2^62 为 long long int 类型2的幂次方最大值 
	cout << "Input number: " << num;

	cout << "\n\n[Solution 1] Is the power of 2 ? " << (PowerOfTwo_1(num) ? "YES\n" : "NO\n");
	cout << "\n\n[Solution 2] Is the power of 2 ? " << (PowerOfTwo_2(num) ? "YES\n" : "NO\n");
	cout << "\n\n[Solution 3] Is the power of 2 ? " << (PowerOfTwo_3(num) ? "YES\n" : "NO\n");
	cout << "\n\n[Solution 4] Is the power of 2 ? " << (PowerOfTwo_4(num) ? "YES\n" : "NO\n");

	cout << endl << endl << INT64_MAX;
	return 0;
}